## 股票问题1（easy）

### 问题来源

https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

### 问题描述

>You are given an array prices where prices[i] is the price of a given stock on the ith day.
>
>You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
>
>Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.

**Example 1:**

> Input: prices = [7,1,5,3,6,4]
> Output: 5
> Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
> Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.


**Example 2:**

> Input: prices = [7,6,4,3,1]
> Output: 0
> Explanation: In this case, no transactions are done and the max profit = 0.

**Constraints:**

> 1 <= prices.length <= 105
> 0 <= prices[i] <= 104

### 算法描述

假设当前访问的位置为$i(0<=i< N)$, 变量`min`表示0~i-1的最小值；

那么可以得到i位置卖出的情况下，可以得到的收益为$price[i]-min$;

遍历每一个位置都可以得到一个答案，那么这些答案中的最大值就是整体的答案,及 $ans = max(price[i]-min)$,  其中1<=i<=N-1

代码实现

``` java
public static int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    // 必须在0时刻卖掉，[0] - [0]
    int ans = 0;
    // arr[0...0]
    int min = prices[0];
    for (int i = 1; i < prices.length; i++) {
        min = Math.min(min, prices[i]);
        ans = Math.max(ans, prices[i] - min);
    }
    return ans;
}
```

### 复杂度分析

时间复杂度$O(N)$
空间复杂度$O(1)$

## 股票问题2(medium)

### 问题来源

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/

### 问题描述

> You are given an integer array prices where prices[i] is the price of a given stock on the ith day.
>
> On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.
>
> Find and return the maximum profit you can achieve.


**Example 1:**

> Input: prices = [7,1,5,3,6,4]
> Output: 7
> Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
> Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
> Total profit is 4 + 3 = 7.

**Example 2:**

>Input: prices = [1,2,3,4,5]
>Output: 4
>Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
>Total profit is 4.

**Example 3:**

> Input: prices = [7,6,4,3,1]
> Output: 0
> Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.


**Constraints:**

> 1 <= prices.length <= 3 * 104
> 0 <= prices[i] <= 104

### 问题分析

该问题与问题1的差别是可以买卖多次，但是手里最多只能留一只股票

对于任意i位置（1~N-1）位置， 只要price[i]-price[i-1]是有收益的，就一定可以获得这个收益，如果是没有收益的，就获得0的收益， 所以$ans =\sum_{i=1}^{N-1}max(price[i]-price[i-1], 0)$

### 算法实现

``` java
public static int maxProfit(int[] prices) {
    if (prices == null || prices.length == 0) {
        return 0;
    }
    int ans = 0;
    for (int i = 1; i < prices.length; i++) {
        ans += Math.max(prices[i] - prices[i-1], 0);
    }
    return ans;
}
```

### 复杂度分析

时间复杂度$O(N)$
空间复杂度$O(1)$

## 股票问题3

### 问题来源

https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/

### 问题描述

>You are given an array prices where prices[i] is the price of a given stock on the ith day.
>
>Find the maximum profit you can achieve. You may complete at most two transactions.
>
>Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).



**Example 1:**

>Input: prices = [3,3,5,0,0,3,1,4]
>Output: 6
>Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.
>Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.

**Example 2:**

>Input: prices = [1,2,3,4,5]
>Output: 4
>Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
>Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.

**Example 3:**

> Input: prices = [7,6,4,3,1]
> Output: 0
> Explanation: In this case, no transaction is done, i.e. max profit = 0.

**Constraints:**

>1 <= prices.length <= 105
>0 <= prices[i] <= 105

### 问题分析

该问题是股票问题4的特殊情况，直接看股票问题4即可

## 股票问题4（hard）

### 问题来源

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/

### 问题描述

>You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.
>
>Find the maximum profit you can achieve. You may complete at most k transactions.
>
>Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

**Example 1:**

>Input: k = 2, prices = [2,4,1]
>Output: 2
>Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.

**Example 2:**

>Input: k = 2, prices = [3,2,6,5,0,3]
>Output: 7
>Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.


**Constraints:**

>0 <= k <= 100
>0 <= prices.length <= 1000
>0 <= prices[i] <= 1000

### 算法分析

数组的总数量是$N$, 考虑K的几种情况：

- $K >= N/2$, 等同于无限次交易
  **解释**：
  数组里最多有N/2次上坡过程，例如[1,2,1,2,1,2]，有3次上坡

- $K < N/2$
  这种情况需要进一步讨论

下面是如何处理 $K < N/2$的情况：

设定$dp[i][j]$表示在$0..i$的范围，不超过$j$次交易，能够获取的最大收益,那么$dp[N-1][K]$就是最终的答案。

接下来就是如何填写这张dp表：

- 第1行，只是用0~0的范围，进行0次交易，收益是0；进行1次交易，收益也是0；直到进行k次交易，收益依然是0

- 第1列，可以进行0次交易，也就是没有交易，收益也都是0

- 考虑任意$i,j$位置，例如$dp[5][4]$
  如果在price[0..5]最多进行4次交易，会有下列几种情况：
  那么最后一次交易一定是在5时刻卖出的。那么最后一次交易是哪里买入的呢？

    - p1: 5位置不参与交易
      可以得到$dp[5][4] = dp[4][4]$
    - p2：5位置参与最后一次交易
        - p2.1 最后一次交易是在5时刻买入的，最后一次交易的收益是0；$dp[5][4] = dp[5][3] + price[5]-price[5]$
        - p2.2：最后一次交易是在4时刻进行的，那么可以得到$dp[5][4] = dp[4][3] + price[5]-price[4]$， 同理可以推出最后一次的买入时机为3时刻，2时刻，1时刻，0时刻

  小结一下,可以得到
  $$
  dp[5][4]^1= dp[4][4], 5位置不参与最后一次交易
  $$

  $$
  dp[5][4]^2=  price[5] + max
  \begin{cases}
  &dp[5][3] -&price[5], &\text 最后一次交易是5时刻买入 \\
  &dp[4][3] -&price[4], &\text 最后一次交易是4时刻买入 \\
  &\vdots &\vdots &\vdots &\vdots \\
  &dp[0][3] -&price[0], &\text 最后一次交易是0时刻买入 \\
  \end{cases}
  $$

  $$
  dp[5][4] = max
  \begin{cases}
  &dp[5][4]^1, &5位置不参与最后一次交易 \\
  &dp[5][4]^2, &5位置参与最后一次交易 \\
  \end{cases}
  $$

  进一步，可以得到$dp[6][4]$的结果为：
  $$
  dp[6][4]^1= dp[5][4], 6位置不参与最后一次交易
  $$

  $$
  dp[6][4]^2= max
  \begin{cases}
  &dp[6][3] + &price[6]-&price[6], &\text 最后一次交易是6时刻买入 \\
  &dp[5][3] + &price[6]-&price[5], &\text 最后一次交易是5时刻买入 \\
  &\vdots &\vdots &\vdots &\vdots \\
  &dp[0][3] + &price[6]-&price[0], &\text 最后一次交易是0时刻买入 \\
  \end{cases}
  $$

  变形一下得到：
  $$
  dp[6][4]^2= price[6] + max
  \begin{cases}
  & dp[6][3]  - &price[6], &\text 最后一次交易是6时刻买入 \\
  & dp[5][3]  - &price[5], &\text 最后一次交易是5时刻买入 \\
  & \vdots      &\vdots &\vdots\\
  &dp[0][3]  - &price[0], &\text 最后一次交易是0时刻买入 \\
  \end{cases}
  $$

  通过观察可以发现，有重复的计算，$dp[6][4]$可以借用$dp[5][4]$的结果



### 代码实现

``` java
	public static int maxProfit2(int K, int[] arr) {
		if (arr == null || arr.length == 0 || K < 1) {
			return 0;
		}
		int N = arr.length;
		if (K >= N / 2) {
			return allTrans(arr);
		}
		int[][] dp = new int[N][K + 1];
		// dp[...][0] = 0
		// dp[0][...] = arr[0.0] 0
		for (int j = 1; j <= K; j++) {
			// dp[1][j]
			int p1 = dp[0][j]; //1位置不参与买卖
			int best = Math.max(dp[1][j - 1] - arr[1], dp[0][j - 1] - arr[0]); //1位置参与交易
			dp[1][j] = Math.max(p1, best + arr[1]);
			// dp[1][j] 准备好一些枚举，接下来准备好的枚举
			for (int i = 2; i < N; i++) {
				p1 = dp[i - 1][j]; //i位置不参与买卖
				int newP = dp[i][j - 1] - arr[i]; //最后一次交易是j时刻买入, 更新枚举值部分
				best = Math.max(newP, best);
				dp[i][j] = Math.max(p1, best + arr[i]);
			}
		}
		return dp[N - 1][K];
	}
```



## 股票问题5（hard）

### 问题来源

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/

### 问题描述

> You are given an array prices where prices[i] is the price of a given stock on the ith day.
>
> Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:
>
> After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).
> Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).



**Example 1:**

> Input: prices = [1,2,3,0,2]
> Output: 3
> Explanation: transactions = [buy, sell, cooldown, buy, sell]

**Example 2:**

> Input: prices = [1]
> Output: 0

**Constraints**:

> 1 <= prices.length <= 5000
> 0 <= prices[i] <= 1000

### 问题分析



